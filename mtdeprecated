#!/usr/bin/php
<?php

require __DIR__ . '/src/CLI.php';

/**
 * Scans for methods, functions and hooks that have been deprecated.
 *
 * Relies on both WP CLI and WP Parser being available and configured as expected
 * (ie, "wp" is on the path and WP Parser is activated within the current WordPress
 * installation).
 */
class Tribe_Product_Util_Deprecated_Items_Finder extends \TUT\CLI {
	/**
	 * Friendly plugin name
	 */
	public $friendly_script_name = 'Deprecated hooks and methods locator';

	protected $earlier_release = '';
	protected $current_release = '';
	protected $current_plugin  = '';

	protected $report = '';


	public function __construct() {
		$this->preflight();
		parent::__construct();
		$this->process();
		$this->save_report();
	}

	protected function preflight() {
		// If WP CLI hasn't been setup, let's bail
		$wp_cli = shell_exec( 'which wp' );

		if ( empty( $wp_cli ) ) {
			print "***********************************\n"
			    . "WP CLI must be installed and should\n"
			    . "be available on the path as 'wp'...\n"
			    . "please fix!\n"
			    . "***********************************\n";
			exit( 1 );
		}

		// If WP Parser isn't ready to use, let's bail
		$wp_parser = shell_exec( 'wp plugin list | grep phpdoc-parser' );

		if ( empty( $wp_parser ) || false !== strpos( $wp_parser, 'inactive' ) ) {
			print "*********************************\n"
				. "WP Parser (phpdoc-parser) must be\n"
				. "activated before you can use this\n"
				. "tool ... please fix!\n"
				. "*********************************\n";
			exit( 1 );
		}
	}

	protected function process() {
		$this->headline_report();

		foreach ( $this->selected_plugins as $plugin ) {
			$this->current_plugin = $plugin;
			$this->process_single_plugin();
		}
	}

	protected function process_single_plugin() {
		$plugin_dir = "{$this->origin_dir}/{$this->current_plugin}";
		chdir( $plugin_dir );

		$this->collect_params();
		$this->sync_branch( $this->current_release );
		$this->document_changed_files();
	}

	protected function collect_params() {
		$last_tag       = $this->last_tag();
		$current_branch = $this->get_branch();

		print "\nCurrent plugin: " . strtoupper( $this->current_plugin ) . "\n";

		$this->earlier_release = $this->prompt_and_confirm(
			  "We need to discover which hooks and methods have already been deprecated.\n"
			. "Which branch or tag should we look at? Hint! the most recent tagged release\n"
			. "appears to be $last_tag.\n",
			"Are you sure %s is the earlier/baseline release?"
		);

		$this->current_release = $this->prompt_and_confirm(
			  "Which branch (or tag) should we look at to discover what else has been\n"
			. "deprecated since $last_tag? Hint! $current_branch is currently checked out.\n",
			'Are you sure %s is the correct branch/tag to scan?'
		);

		if ( empty( $this->earlier_release ) || empty( $this->current_release ) ) {
			print "*****************************\n"
			    . "You MUST specify the releases\n"
			    . "you are interested in or bad\n"
			    . "things may occur. Bailing.\n"
			    . "*****************************\n";
			exit( 1 );
		}
	}

	protected function headline_report() {
		$this->report =
			  "DEPRECATED CLASSES, FUNCTIONS AND HOOKS\n"
			. "---------------------------------------\n\n";
	}

	protected function document_changed_files() {
		$earlier_hash = $this->get_revision_hash( $this->earlier_release );
		$changed_php_files = explode( "\n", shell_exec( "git diff --name-only $earlier_hash | grep .php" ) );
		$changed_php_files = array_filter( $changed_php_files );

		if ( empty( $changed_php_files ) ) {
			print "{$this->current_plugin}: No differences found between PHP files in each release, skipping!\n";
			return;
		}

		$currently_deprecated = $this->get_deprecated_items( $changed_php_files );
		$this->sync_branch( $this->earlier_release );
		$already_deprecated = $this->get_deprecated_items( $changed_php_files );
		$this->sync_branch( $this->current_release );

		$this->report .= $this->current_plugin . ":\n"
			. str_pad( '', strlen( $this->current_plugin ) + 1, '-' ) . "\n";

		$deprecated = array_diff( $currently_deprecated, $already_deprecated );
		foreach ( $deprecated as $item ) {
			$this->report .= "\t{$item}\n";
		}

		if ( empty( $deprecated ) ) {
			$this->report .= "\tNo newly deprecated items found\n";
		}

		$this->report .= "\n";
	}

	protected function get_deprecated_items( $src_files ) {
		$all_deprecated_items = [];

		foreach ( $src_files as $modified_src_file ) {
			// File may not exist in either the earlier or current release
			if ( ! file_exists( $modified_src_file ) ) {
				continue;
			}

			// Ignore tests/ and vendors/
			if ( 0 === strpos( $modified_src_file, 'tests/' ) || 0 === strpos( $modified_src_file, 'vendor/' ) ) {
				continue;
			}

			foreach ( $this->get_documentation( $modified_src_file ) as $docs ) {
				$deprecated_items = array_merge(
					$this->scan_files( $docs ),
					$this->scan_classes( $docs ),
					$this->scan_functions( $docs ),
					$this->scan_hooks( $docs )
				);

				$all_deprecated_items = array_merge( $all_deprecated_items, $deprecated_items );
			};
		}

		return $all_deprecated_items;
	}

	protected function scan_files( $doc_object ) {
		$file = [];

		if ( empty( $doc_object->file ) ) {
			return [];
		}

		$file = $this->find_deprecated( $doc_object->file, '[File] ' );

		return $file;
	}

	protected function scan_classes( $doc_object ) {
		$classes_methods = [];

		if ( empty( $doc_object->classes ) ) {
			return [];
		}

		foreach ( $doc_object->classes as $class ) {
			if ( empty( $class->methods ) ) {
				continue;
			}

			$classes_methods = array_merge(
				$classes_methods,
				$this->find_deprecated( $class, '[Class] ' ),
				$this->find_deprecated( $class->methods, '[Method] ' . $class->name . '::', '()' )
			);
		}

		return array_filter( $classes_methods );
	}

	protected function scan_functions( $doc_object ) {
		$functions = [];

		if ( empty( $doc_object->functions ) ) {
			return [];
		}

		foreach ( $doc_object->functions as $functions ) {
			if ( empty( $functions ) ) {
				continue;
			}

			$functions = $this->find_deprecated( $functions, '[Function] ', '()' );
		}

		return array_filter( $functions );
	}

	protected function scan_hooks( $doc_object ) {
		$hooks = [];

		if ( empty( $doc_object->hooks ) ) {
			return [];
		}

		foreach ( $doc_object->hooks as $hooks ) {
			if ( empty( $hooks ) ) {
				continue;
			}

			$hooks = $this->find_deprecated( $hooks, '[Hook] ' );
		}

		return array_filter( $hooks );
	}

	protected function find_deprecated( $inner_doc_object, $prepend_to_ref = '', $append_to_ref = '' ) {
		$items = [];

		foreach ( $inner_doc_object as $item ) {
			if ( empty( $item->doc ) ) {
				continue;
			}

			if ( empty( $item->doc->tags ) ) {
				continue;
			}

			// If this item is a method or function, etc, it may itself contain hooks
			if ( ! empty( $item->hooks ) ) {
				$items = array_merge( $items, $this->find_deprecated( $item->hooks, '[Hook] ' ) );
			}

			foreach ( $item->doc->tags as $tag ) {
				if ( 'deprecated' !== $tag->name ) {
					continue;
				}

				$reference = $prepend_to_ref . $item->name . $append_to_ref;
				$items[] = $reference;
			}
		}

		return $items;
	}

	protected function get_documentation( $src_file ) {
		$tmp_json_file = sys_get_temp_dir() . '/tribe_deprecated_code_docs_' . uniqid() . '.json';
		shell_exec( "wp parser export $src_file $tmp_json_file" );
		$data = json_decode( file_get_contents( $tmp_json_file ) );
		unlink( $tmp_json_file );
		return (array) $data;
	}

	protected function save_report() {
		$filename = sys_get_temp_dir() . '/deprecated_items_report.txt';
		$success  = file_put_contents( $filename, $this->report );

		if ( $success ) {
			print "*********************\n"
			    . "Report saved to:\n"
			    . "$filename\n"
			    . "*********************\n";
		} else {
			print "****************************\n"
			    . "Unable to save the report,\n"
			    . "printing to console instead!\n"
			    . "****************************\n\n{$this->report}";
		}
	}
}

new Tribe_Product_Util_Deprecated_Items_Finder();
